
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      --><title>env</title><meta name="generator" content="MATLAB 7.9"><meta name="date" content="2012-05-03"><meta name="m-file" content="env"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><h1>env</h1><!--introduction--><p>Fit the envelope model.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Usage</a></li><li><a href="#2">Description</a></li><li><a href="#3">References</a></li><li><a href="#4">Example</a></li></ul></div><h2>Usage<a name="1"></a></h2><p>stat=env(X,Y,u,opts)</p><p>Input</p><p>X: Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p><p>Y: Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables, and r should be strictly greater than p.</p><p>u: Dimension of the envelope. An integer between 0 and r.</p><p>opts: A list containing the optional input parameter, to control the iterations in sg_min. If one or several (even all) fields are not defined, the default settings are used.</p><div><ul><li>opts.maxIter: Maximum number of iterations.  Default value: 300.</li><li>opts.ftol: Tolerance parameter for F.  Default value: 1e-10.</li><li>opts.gradtol: Tolerance parameter for dF.  Default value: 1e-7.</li><li>opts.verbose: Flag for print out output, logical 0 or 1. Default value: 0.</li></ul></div><p>Output</p><p>stat: A list that contains the maximum likelihood estimators and some statistics.</p><div><ul><li>stat.beta: The envelope estimator of the regression coefficients <img src="env_eq83200.png" alt="$$\beta$">. An r by p matrix.</li><li>stat.Sigma: The envelope estimator of the error covariance matrix.  An r by r matrix.</li><li>stat.Gamma: The orthogonal basis of the envelope subspace. An r by u semi-orthogonal matrix.</li><li>stat.Gamma0: The orthogonal basis of the complement of the envelope subspace.  An r by r-u semi-orthogonal matrix.</li><li>stat.eta: The coordinates of <img src="env_eq83200.png" alt="$$\beta$"> with respect to Gamma. An u by p matrix.</li><li>stat.Omega: The coordinates of Sigma with respect to Gamma. An u by u matrix.</li><li>stat.Omega0: The coordinates of Sigma with respect to Gamma0. An r-u by r-u matrix.</li><li>stat.alpha: The estimated intercept in the envelope model.  An r by 1 vector.</li><li>stat.l: The maximized log likelihood function.  A real number.</li><li>stat.asyEnv: Asymptotic standard error for elements in <img src="env_eq83200.png" alt="$$\beta$"> under the envelope model.  An r by p matrix.  The standard errors returned are asymptotic, for actual standard errors, multiply by 1/sqrt(n).</li><li>stat.ratio: The asymptotic standard error ratio of the standard multivariate linear regression estimator over the envelope estimator, for each element in <img src="env_eq83200.png" alt="$$\beta$">.  An r by p matrix.</li><li>stat.np: The number of parameters in the envelope model.  A positive integer.</li></ul></div><h2>Description<a name="2"></a></h2><p>This function fits the envelope model to the responses and predictors, using the maximum likehood estimation.  When the dimension of the envelope is between 1 and r-1, we implemented the algorithm in Cook et al. (2010).  When the dimension is r, then the envelope model degenerates to the standard multivariate linear regression.  When the dimension is 0, it means that X and Y are uncorrelated, and the fitting is different.</p><h2>References<a name="3"></a></h2><div><ul><li>The codes is implemented based on the algorithm in Section 4.3 of Cook et al (2010).</li><li>The Grassmann manifold optimization step calls the package sg_min 2.4.1 by Ross Lippert (<a href="http://web.mit.edu/~ripper/www.sgmin.html)">http://web.mit.edu/~ripper/www.sgmin.html)</a>.</li></ul></div><h2>Example<a name="4"></a></h2><p>The following codes will reconstruct the results in the wheat protein data example in Cook et al. (2010).</p><p>load wheatprotein.txt X=wheatprotein(:,8); Y=wheatprotein(:,1:6); alpha=0.01; u=lrt_env(X,Y,alpha) stat=env(X,Y,u) stat.Omega eig(stat.Omega0) stat.ratio</p><pre class="codeinput"><span class="keyword">function</span> stat=env(X,Y,u,opts)

<span class="comment">% Verify and initialize the parameters</span>
<span class="comment">%</span>
<span class="keyword">if</span> (nargin &lt; 3)
    error(<span class="string">'Inputs: X, Y and u should be specified!'</span>);
<span class="keyword">elseif</span> (nargin==3)
    opts=[];
<span class="keyword">end</span>

[n,p]=size(X);
[n1,r]=size(Y);

<span class="keyword">if</span> (n ~= n1)
    error(<span class="string">'The number of observations in X and Y should be equal!'</span>);
<span class="keyword">end</span>

<span class="keyword">if</span> (p &gt;= r)
    error(<span class="string">'When the number of responses is less than the number of predictors, the envelope model cannot be applied.'</span>);
<span class="keyword">end</span>

u = floor(u);
<span class="keyword">if</span> (u &lt; 0 || u &gt; r)
    error(<span class="string">'u should be an integer between [0, r]!'</span>);
<span class="keyword">end</span>

opts=make_opts(opts);

<span class="keyword">if</span> isfield(opts,<span class="string">'init'</span>)
    [r2,u2]=size(opts.init);

    <span class="keyword">if</span> (r ~= r2 || u ~= u2)
        error(<span class="string">'The size of the initial value should be r by u!'</span>);
    <span class="keyword">end</span>

    <span class="keyword">if</span> (rank(opts.init) &lt; u2)
        error(<span class="string">'The initial value should be full rank!'</span>);
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="comment">%---preparation---</span>
dataParameter=make_parameter(X,Y,<span class="string">'env'</span>);

n=dataParameter.n;
p=dataParameter.p;
r=dataParameter.r;
mX=dataParameter.mX;
mY=dataParameter.mY;
sigX=dataParameter.sigX;
sigY=dataParameter.sigY;
sigRes=dataParameter.sigRes;
betaOLS=dataParameter.betaOLS;

eigtem=eig(sigY);

F = make_F(@F4env,dataParameter);
dF = make_dF(@dF4env,dataParameter);


<span class="comment">% With different u, the model will be different.  When u=0, X and Y are</span>
<span class="comment">% uncorrelated, so it should be fitted differently.  When u=r, the envelope</span>
<span class="comment">% model reduces to the standard model, and it also should be fitted</span>
<span class="comment">% differently.</span>


<span class="keyword">if</span> u&gt;0 &amp;&amp; u&lt;r


    <span class="comment">%---Compute \Gamma using sg_min---</span>
    maxIter=opts.maxIter;
	ftol=opts.ftol;
	gradtol=opts.gradtol;
	<span class="keyword">if</span> (opts.verbose==0)
        verbose=<span class="string">'quiet'</span>;
    <span class="keyword">else</span>
        verbose=<span class="string">'verbose'</span>;
    <span class="keyword">end</span>
    <span class="keyword">if</span> ~isfield(opts,<span class="string">'init'</span>)
        init=get_Init(F,X,Y,u,dataParameter);
    <span class="keyword">else</span>
        init=opts.init;
    <span class="keyword">end</span>

    [l Gamma]=sg_min(F,dF,init,maxIter,<span class="string">'prcg'</span>,verbose,ftol,gradtol);


    <span class="comment">%---Compute the rest of the parameters based on \Gamma---</span>
    Gamma0=grams(nulbasis(Gamma'));
    beta=Gamma*Gamma'*betaOLS;
    alpha=mY-beta*mX;
    eta=Gamma'*beta;
    Omega=Gamma'*sigRes*Gamma;
    Omega0=Gamma0'*sigY*Gamma0;
    Sigma1=Gamma*Omega*Gamma';
    Sigma2=Gamma0*Omega0*Gamma0';
    Sigma=Sigma1+Sigma2;

    <span class="comment">%---compute asymptotic variance and get the ratios---</span>
    asyFm=kron(inv(sigX),Sigma);
    asyFm=reshape(sqrt(diag(asyFm)),r,p);
    temp=kron(eta*sigX*eta',inv(Omega0))+kron(Omega,inv(Omega0))+kron(inv(Omega),Omega0)-2*kron(eye(u),eye(r-u));
    asyEnv=kron(inv(sigX),Sigma1)+kron(eta',Gamma0)*inv(temp)*kron(eta,Gamma0');
    asyEnv=reshape(sqrt(diag(asyEnv)),r,p);


    stat.beta=beta;
    stat.Sigma=Sigma;
    stat.Gamma=Gamma;
    stat.Gamma0=Gamma0;
    stat.eta=eta;
    stat.Omega=Omega;
    stat.Omega0=Omega0;
    stat.alpha=alpha;
    stat.l=-n*r/2*(1+log(2*pi))-n/2*(l+log(prod(eigtem(eigtem&gt;0))));
    stat.asyEnv=asyEnv;
    stat.ratio=asyFm./asyEnv;
    stat.np=r+u*p+r*(r+1)/2;


<span class="keyword">elseif</span> u==0


    stat.beta=zeros(r,p);
    stat.Sigma=sigY;
    stat.Gamma=[];
    stat.Gamma0=eye(r);
    stat.eta=[];
    stat.Omega=[];
    stat.Omega0=sigY;
    stat.alpha=mY;
    stat.l=-n*r/2*(1+log(2*pi))-n/2*log(prod(eigtem(eigtem&gt;0)));
    stat.asyEnv=[];
    stat.ratio=ones(r,p);
    stat.np=r+u*p+r*(r+1)/2;


<span class="keyword">elseif</span> u==r


    asyFm=kron(inv(sigX),sigRes);
    asyFm=reshape(sqrt(diag(asyFm)),r,p);

    stat.beta=betaOLS;
    stat.Sigma=sigRes;
    stat.Gamma=eye(r);
    stat.Gamma0=[];
    stat.eta=betaOLS;
    stat.Omega=sigRes;
    stat.Omega0=[];
    stat.alpha=mY-betaOLS*mX;
    eigtem=eig(sigRes);
    stat.l=-n*r/2*(1+log(2*pi))-n/2*log(prod(eigtem(eigtem&gt;0)));
    stat.asyEnv=asyFm;
    stat.ratio=ones(r,p);
    stat.np=r+u*p+r*(r+1)/2;


<span class="keyword">end</span>
</pre><pre class="codeoutput">Error using ==&gt; env at 94
Inputs: X, Y and u should be specified!
</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.9<br></p></div><!--
##### SOURCE BEGIN #####
%% env
% Fit the envelope model.

%% Usage
% stat=env(X,Y,u,opts)
%
% Input
%
% X: Predictors. An n by p matrix, p is the number of predictors. The
% predictors can be univariate or multivariate, discrete or continuous.
% 
% Y: Multivariate responses. An n by r matrix, r is the number of
% responses and n is number of observations. The responses must be 
% continuous variables, and r should be strictly greater than p.
% 
% u: Dimension of the envelope. An integer between 0 and r.
% 
% opts: A list containing the optional input parameter, to control the
% iterations in sg_min. If one or several (even all) fields are not
% defined, the default settings are used.
% 
% * opts.maxIter: Maximum number of iterations.  Default value: 300.
% * opts.ftol: Tolerance parameter for F.  Default value: 1e-10. 
% * opts.gradtol: Tolerance parameter for dF.  Default value: 1e-7.
% * opts.verbose: Flag for print out output, logical 0 or 1. Default value: 0.
%
% Output
% 
% stat: A list that contains the maximum likelihood estimators and some
% statistics.
% 
% * stat.beta: The envelope estimator of the regression coefficients $$\beta$. 
% An r by p matrix.
% * stat.Sigma: The envelope estimator of the error covariance matrix.  An r by
% r matrix.
% * stat.Gamma: The orthogonal basis of the envelope subspace. An r by u
% semi-orthogonal matrix.
% * stat.Gamma0: The orthogonal basis of the complement of the envelope
% subspace.  An r by r-u semi-orthogonal matrix.
% * stat.eta: The coordinates of $$\beta$ with respect to Gamma. An u by p
% matrix.
% * stat.Omega: The coordinates of Sigma with respect to Gamma. An u by u
% matrix.
% * stat.Omega0: The coordinates of Sigma with respect to Gamma0. An r-u by r-u
% matrix.
% * stat.alpha: The estimated intercept in the envelope model.  An r by 1
% vector.
% * stat.l: The maximized log likelihood function.  A real number.
% * stat.asyEnv: Asymptotic standard error for elements in $$\beta$ under
% the envelope model.  An r by p matrix.  The standard errors returned are
% asymptotic, for actual standard errors, multiply by 1/sqrt(n).
% * stat.ratio: The asymptotic standard error ratio of the standard multivariate 
% linear regression estimator over the envelope estimator, for each element 
% in $$\beta$.  An r by p matrix.
% * stat.np: The number of parameters in the envelope model.  A positive
% integer.


%% Description
% This function fits the envelope model to the responses and predictors,
% using the maximum likehood estimation.  When the dimension of the
% envelope is between 1 and r-1, we implemented the algorithm in Cook et
% al. (2010).  When the dimension is r, then the envelope model degenerates
% to the standard multivariate linear regression.  When the dimension is 0,
% it means that X and Y are uncorrelated, and the fitting is different.

%% References
% 
% * The codes is implemented based on the algorithm in Section 4.3 of Cook 
% et al (2010).
% * The Grassmann manifold optimization step calls the package sg_min 2.4.1
% by Ross Lippert (http://web.mit.edu/~ripper/www.sgmin.html).

%% Example
%
% The following codes will reconstruct the results in the wheat protein data
% example in Cook et al. (2010).
%
% load wheatprotein.txt
% X=wheatprotein(:,8);
% Y=wheatprotein(:,1:6);
% alpha=0.01;
% u=lrt_env(X,Y,alpha)
% stat=env(X,Y,u)
% stat.Omega
% eig(stat.Omega0)
% stat.ratio

function stat=env(X,Y,u,opts)

% Verify and initialize the parameters
%
if (nargin < 3)
    error('Inputs: X, Y and u should be specified!');
elseif (nargin==3)
    opts=[];
end

[n,p]=size(X);
[n1,r]=size(Y);

if (n ~= n1)
    error('The number of observations in X and Y should be equal!');
end

if (p >= r)
    error('When the number of responses is less than the number of predictors, the envelope model cannot be applied.');
end

u = floor(u);
if (u < 0 || u > r)
    error('u should be an integer between [0, r]!');
end

opts=make_opts(opts);

if isfield(opts,'init')
    [r2,u2]=size(opts.init);

    if (r ~= r2 || u ~= u2)
        error('The size of the initial value should be r by u!');
    end

    if (rank(opts.init) < u2)
        error('The initial value should be full rank!');
    end
end


%REPLACE_WITH_DASH_DASH-preparationREPLACE_WITH_DASH_DASH-
dataParameter=make_parameter(X,Y,'env');

n=dataParameter.n;
p=dataParameter.p;
r=dataParameter.r;
mX=dataParameter.mX;
mY=dataParameter.mY;
sigX=dataParameter.sigX;
sigY=dataParameter.sigY;
sigRes=dataParameter.sigRes;
betaOLS=dataParameter.betaOLS;

eigtem=eig(sigY);

F = make_F(@F4env,dataParameter);
dF = make_dF(@dF4env,dataParameter);


% With different u, the model will be different.  When u=0, X and Y are
% uncorrelated, so it should be fitted differently.  When u=r, the envelope
% model reduces to the standard model, and it also should be fitted
% differently.


if u>0 && u<r


    %REPLACE_WITH_DASH_DASH-Compute \Gamma using sg_minREPLACE_WITH_DASH_DASH-
    maxIter=opts.maxIter;
	ftol=opts.ftol;
	gradtol=opts.gradtol;
	if (opts.verbose==0) 
        verbose='quiet';
    else
        verbose='verbose';
    end
    if ~isfield(opts,'init') 
        init=get_Init(F,X,Y,u,dataParameter);
    else
        init=opts.init;
    end

    [l Gamma]=sg_min(F,dF,init,maxIter,'prcg',verbose,ftol,gradtol);


    %REPLACE_WITH_DASH_DASH-Compute the rest of the parameters based on \GammaREPLACE_WITH_DASH_DASH-
    Gamma0=grams(nulbasis(Gamma'));
    beta=Gamma*Gamma'*betaOLS;
    alpha=mY-beta*mX;
    eta=Gamma'*beta;
    Omega=Gamma'*sigRes*Gamma;
    Omega0=Gamma0'*sigY*Gamma0;
    Sigma1=Gamma*Omega*Gamma';
    Sigma2=Gamma0*Omega0*Gamma0';
    Sigma=Sigma1+Sigma2;

    %REPLACE_WITH_DASH_DASH-compute asymptotic variance and get the ratiosREPLACE_WITH_DASH_DASH-
    asyFm=kron(inv(sigX),Sigma);
    asyFm=reshape(sqrt(diag(asyFm)),r,p);
    temp=kron(eta*sigX*eta',inv(Omega0))+kron(Omega,inv(Omega0))+kron(inv(Omega),Omega0)-2*kron(eye(u),eye(r-u));
    asyEnv=kron(inv(sigX),Sigma1)+kron(eta',Gamma0)*inv(temp)*kron(eta,Gamma0');
    asyEnv=reshape(sqrt(diag(asyEnv)),r,p);
    
    
    stat.beta=beta;
    stat.Sigma=Sigma;
    stat.Gamma=Gamma;
    stat.Gamma0=Gamma0;
    stat.eta=eta;
    stat.Omega=Omega;
    stat.Omega0=Omega0;
    stat.alpha=alpha;
    stat.l=-n*r/2*(1+log(2*pi))-n/2*(l+log(prod(eigtem(eigtem>0))));
    stat.asyEnv=asyEnv;
    stat.ratio=asyFm./asyEnv;
    stat.np=r+u*p+r*(r+1)/2;
    
    
elseif u==0
    
    
    stat.beta=zeros(r,p);
    stat.Sigma=sigY;
    stat.Gamma=[];
    stat.Gamma0=eye(r);
    stat.eta=[];
    stat.Omega=[];
    stat.Omega0=sigY;
    stat.alpha=mY;
    stat.l=-n*r/2*(1+log(2*pi))-n/2*log(prod(eigtem(eigtem>0)));
    stat.asyEnv=[];
    stat.ratio=ones(r,p);
    stat.np=r+u*p+r*(r+1)/2;
    

elseif u==r
    
 
    asyFm=kron(inv(sigX),sigRes);
    asyFm=reshape(sqrt(diag(asyFm)),r,p);
    
    stat.beta=betaOLS;
    stat.Sigma=sigRes;
    stat.Gamma=eye(r);
    stat.Gamma0=[];
    stat.eta=betaOLS;
    stat.Omega=sigRes;
    stat.Omega0=[];
    stat.alpha=mY-betaOLS*mX;
    eigtem=eig(sigRes);
    stat.l=-n*r/2*(1+log(2*pi))-n/2*log(prod(eigtem(eigtem>0)));
    stat.asyEnv=asyFm;
    stat.ratio=ones(r,p);
    stat.np=r+u*p+r*(r+1)/2;
    
    
end
    
    
    
##### SOURCE END #####
--></body></html>